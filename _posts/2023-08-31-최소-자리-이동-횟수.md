---
layout: post
title: 2037. Minimum Number of Moves to Seat Everyone
subtitle: 모두가 제자리에 앉기 위한 최소 이동 횟수
categories: [LeetCode Problems]
tags: [LeetCode, C++]
---


## 문제 설명
<b>[(문제 링크)](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/)</b>
<span style="color:green"><b>난이도: 쉬움</b></span>

방에 `n`개의 앉을 자리와 `n`명의 학생이 있다. 주어진 길이 `n`인 배열 `seats`에서 `seats[i]`는 <code>i<sup>th</sup></code> 자리의 위치를 나타낸다. 또다른 주어진 길이 `n`인 배열 `students`에서 `students[j]`는 <code>j<sup>th</sup></code> 학생의 위치를 나타낸다.

다음 행동을 임의의 횟수 실행한다.
  * <code>i<sup>th</sup></code> 학생의 위치를 1만큼 증가 또는 감소시킨다. (예시: 위치 `x`에 있는 <code>i<sup>th</sup></code> 학생의 위치를 `x + 1` 또는 `x - 1`로 옮김)

*두 학생이 같은 자리에 앉지 않도록, 각 학생이 자리로 이동하기 위해 필요한 **최소 이동 횟수***를 반환(return)하라.

처음에 **여러** 자리나 학생이 **같은** 위치에 있을 수 있음에 주의하시오.

**예시 1:**<br>
**입력:** `seats = [3,1,5], students = [2,7,4]`<br>
**출력:** `4`<br>
해설: 학생들의 이동을 표현하면 다음과 같다.
  * 첫 번째 학생은 위치 2에서 위치 1로 1번 이동했다.
  * 두 번째 학생은 위치 7에서 위치 5로 2번 이동했다.
  * 세 번째 학생은 위치 4에서 위치 3으로 1번 이동했다.

종합해서 1 + 2 + 1 = 4번 이동하였다.

**예시 2:**<br>
**입력:** `seats = [4,1,5,9], students = [1,3,2,6]`<br>
**출력:** `7`<br>
**해설:** 학생들의 이동을 표현하면 다음과 같다.
  * 첫 번째 학생은 이동하지 않았다.
  * 두 번째 학생은 위치 3에서 위치 4로 1번 이동했다.
  * 세 번째 학생은 위치 2에서 위치 5로 3번 이동했다.
  * 네 번째 학생은 위치 6에서 위치 9로 3번 이동했다.

종합해서 0 + 1 + 3 + 3 = 7번 이동하였다.

**예시 3:**<br>
**입력:** `seats = [2,2,6,6], students = [1,3,2,6]`<br>
**출력:** `4`<br>
**해설:** 위치 2와 위치 6에 각각 2개의 좌석이 있음에 주의하라.<br>
학생들의 이동을 표현하면 다음과 같다.
  * 첫 번째 학생은 위치 1에서 위치 2로 1번 이동했다.
  * 두 번째 학생은 위치 3에서 위치 6으로 3번 이동했다.
  * 세 번째 학생은 이동하지 않았다.
  * 네 번째 학생은 이동하지 않았다.

종합해서 1 + 3 + 0 + 0 = 4번 이동하였다.

**제약조건:**
  * `n == seats.length == students.length`
  * `1 <= n <= 100`
  * `1 <= seats[i], students[j] <= 100`

## 풀이

처음 문제를 보고 떠오른 풀이법은 'brute force로 풀어버릴까'였다. 각 배열 원소끼리의 차이를 싸그리 구한 다음, 전부 더했을 때 최솟값을 구하자는 거였는데... 역시 시간 복잡도가 미친듯이 올라갈 걸 생각하면 썩 좋은 방법은 아니었다.

그렇게 잠시 생각하다 한 가지 알아차린 것은 '자리가 몇 번째건, 학생이 몇 번째건 그건 중요하지 않다'는 거였다. 문제를 잘 보면 몇 번째 어느 학생이 몇 번째 어느 자리에 가야 하는지는 따지지 않는다. 학생이 남자든 여자든, 자리가 최고급 시트든 뭐든 간에 그냥 자리잡기 위한 이동이 최소이기만 하면 된다. 즉, 예시 1에서 `students` 배열이 `[2,7,4]`든 `[7,4,2]`든 생각해야 하는 것은 같다.

그리하여 생각난 또다른 풀이법은 '위치가 `n`번째로 먼 학생이 `n`번째로 먼 자리를 사수해야 한다'는 것이었다. 만약 자리가 3개, 학생이 3명 아래와 같이 있다고 치자. 5번째 위치의 학생이 최소 이동으로 자리를 사수한다면, 세 자리 중 어디로 가야 하겠는가?

| pos   | 0     | 1     | 2     | 3     | 4     | 5     |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| seats | O     |       | O     | O     |       |       |
| students |    | 🧑‍🎓    |       | 🧑‍🎓   |       | 🧑‍🎓    |

당연히 3번째 위치로 이동해야 한다! 이 경우 5 → 3으로 이동했으니 2번 이동하게 된다. 그런데 위치 3에 자리는 하나뿐이고, 여러 학생이 같은 자리에 있을 수 없으니 기존의 위치 3에 있던 학생은 다른 가까운 자리, 즉 위치 2로 1번 이동해야 할 것이다.

| pos   | 0     | 1     | 2     | 3     | 4     | 5     |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| seats | O     |       | O     | O     |       |       |
| students |    | 🧑‍🎓 | 🧑‍🎓(3 → 2) | 🧑‍🎓(5 → 3) |  |     |

**Total: 3**

방금 예시에서 이렇게 생각할 수도 있을 것이다.

> 위치 3은 이미 학생이 자리잡고 있는데, 위치 2로 이동하는 게 옳은 것 아닌가? 위치 3으로 가게 되면 또다른 학생이 이동해야 하니 이동 횟수가 늘어나는 셈인데.

하지만 실제로 그렇지 않다. 일단 앞의 예시에서 두 학생이 이동했을 때 총 이동 횟수는 2 + 1 = 3회가 된다. 그리고 만약 위치 5에서 위치 2로 학생이 이동하고, 위치 3의 학생은 그대로 있는다면 이 역시 이동 횟수는 3 + 0 = 3회이다. 즉, 이동 횟수가 늘어나는 일은 없다.

| pos   | 0     | 1     | 2     | 3     | 4     | 5     |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| seats | O     |       | O     | O     |       |       |
| students |    | 🧑‍🎓 | 🧑‍🎓(5 → 2) | 🧑‍🎓  |       |       |

**Total: 3**

그러면 **'위치가 `n`번째로 먼 학생이 `n`번째로 먼 자리를 사수해야 한다'**는 생각을 바탕으로 코드를 작성해 보자. 저 문장이 어려워 보이지만, 그냥 가까운 자리는 가까운 놈이, 먼 자리는 먼 놈이 먹는다는 뜻이다.

```C++
class Solution {
public:
    int minMovesToSeat(vector<int>& seats, vector<int>& students) {
        // sort none-decreasing order and subtract each element
        sort(seats.begin(), seats.end());
        sort(students.begin(), students.end());

        int ans = 0;
        for(int i = 0; i < seats.size(); i++) {
            ans += abs(seats[i] - students[i]);
        }

        return ans;
    }
};
```

일단 효율적인 계산을 위해 두 배열을 정렬시킨다. 그러면 위치가 가까운 순서대로 배열이 정렬되므로, 각 배열의 인덱스가 같은 원소끼리 위치값의 차이를 계산한다. 그러면 각 학생이 인접한 자리로 위치이동하는 최솟값을 구할 수 있고, 그 총합이 최소 자리 이동 횟수가 된다.